# plots <- list()
# for(i in 1:500){
#   plot <- plot_grid(mheatmap(mod$w[,,i], title = paste0("Iteration ", i), ylab = "1000 genes", xlab = "10 factors", legend.labels = c(0, 0.01), colors = viridis(100, option = "B"), aspect.ratio = 1.5), mheatmap(mod$h[,,i], ylab = "10 factors", xlab = "1000 cells", legend.labels = c(0, 0.01), colors = viridis(100, option = "B")), nrow = 1, ncol = 2, rel_widths = c(0.4, 0.6))
#   ggsave(filename = paste0("plot", i, ".png"))
# }

#' Plot a projection matrix
#'
#' ggplot2 heatmap of a projection matrix, ideally only for small matrices. For large matrices, see other packages or submit a rasterized or compressed matrix.
#'
#' ggplot2 grammar may be applied to add to or overwrite existing settings.
#'
#' @param h matrix to be plotted
#' @param legend.labels breakpoints for the continuous color scale legend
#' @param xlab x label, or NULL
#' @param ylab y label, or NULL
#' @param title title for the plot, or NULL
#' @param colors array of colors for a gradient (if continuous) or discrete colors (of length corresponding to the number of discrete values in the matrix, or an error will be thrown). If null, an appropriate number of colors will be generated by spinning the ggplot2-style color wheel. An array of numbers may also be specified, corresponding to ggplot color palette indices.
#' @param show.rownames show row names
#' @param show.colnames show column names
#' @param guide.title title of the colorbar guide
#' @param rownames.text.size size of rownames labels
#' @param discrete are the values in h discrete (i.e. multinomial). If so, specify discrete = TRUE and a discrete scale will be supplied.
#' @param legend.key.width width of legend key in unit "cm"
#' @param aspect.ratio theme aspect ratio for the plot (< 1 = wide, > 1 = tall)
#' @param Rowv reorder rows using the hclust ward.d2 method
#' @param Colv reorder columns using the hclust ward.d2 method
#' @param na.color color for NA values
#' @return ggplot2 object
#' @importFrom reshape2 melt
#' @import ggplot2 data.table
#' @importFrom stats dist hclust
#' @importFrom grDevices hcl
#' @export
#'
mheatmap <- function(h,
                     legend.labels = c(0, 1),
                     xlab = NULL,
                     ylab = NULL,
                     title = NULL,
                     show.rownames = "auto",
                     show.colnames = "auto",
                     Rowv = FALSE,
                     Colv = FALSE,
                     guide.title = "mapping\nweight",
                     colors = NULL,
                     na.color = "#fafafa",
                     rownames.text.size = 8,
                     discrete = FALSE,
                     legend.key.width = 0.2,
                     aspect.ratio = 0.5) {
  
  # a ggplot-like color wheel :)
  ggcolors <- function(n) {
    hues <- seq(15, 375, length = n + 1)
    hcl(h = hues, l = 65, c = 100)[1:n]
  }
  
  if(show.rownames == "auto") ifelse(is.null(rownames(h)) || nrow(h) > 25, show.rownames <- FALSE, show.rownames <- TRUE)
  if(show.colnames == "auto") ifelse(is.null(colnames(h)) || ncol(h) > 25, show.colnames <- FALSE, show.colnames <- TRUE)
  
  if (!is.null(colors)) {
    for (i in 1:length(colors))
      if (is.numeric(colors[i])) colors[i] <- ggcolors(100)[colors[i]]
  }
  
  # reorder rows
  if (Rowv) {
    hc <- hclust(dist(h), method = "ward.D2")
    h <- h[hc$order,]
  }
  
  # reorder columns
  if (Colv) {
    hc <- hclust(dist(t(h)), method = "ward.D2")
    h <- h[, hc$order]
  }
  
  # prep the data
  h <- reshape2::melt(h)
  colnames(h) <- c("Var1", "Var2", "value")
  h$Var1 <- factor(h$Var1)
  
  max_h <- max(h$value)
  
  if (discrete) h$value <- factor(h$value)
  
  # plot the data
  hplot <- ggplot(data = h, aes(x = Var2, y = Var1, fill = value)) +
    geom_tile() +
    theme_classic() +
    scale_x_discrete(expand = c(0, 0), position = "top") +
    scale_y_discrete(expand = c(0, 0), limits = rev(levels(h$Var1))) +
    theme(axis.ticks.x = element_blank(),
          axis.ticks.y = element_blank(),
          axis.line = element_blank(),
          plot.title = element_text(hjust = 0.5),
          aspect.ratio = aspect.ratio)
  
  if (!is.null(legend.key.width)) hplot <- hplot + theme(legend.key.width = unit(legend.key.width, "cm"))
  
  if (discrete) {
    if (is.null(colors) || length(colors) != length(levels(h$value))) colors <- c("#fafafa", ggcolors(length(levels(h$value)) - 1))
    hplot <- hplot + scale_fill_discrete(type = colors, breaks = as.numeric(levels(h$value), na.value = na.color), guide_coloursteps(title = guide.title), guide_colourbar(ticks = F, title = guide.title))
  } else {
    if (is.null(colors)) colors <- c("#fafafa", "#31688E")
    hplot <- hplot + scale_fill_gradientn(colours = colors, na.value = na.color, limits = c(0, max(h$value)), breaks = legend.labels, guide_colourbar(ticks = F, title = guide.title))
  }
  ifelse(!is.null(xlab), hplot <- hplot + xlab(xlab), hplot <- hplot + theme(axis.title.x = element_blank()))
  ifelse(!is.null(ylab), hplot <- hplot + ylab(ylab), hplot <- hplot + theme(axis.title.y = element_blank()))
  if (!is.null(title)) hplot <- hplot + labs(title = title)
  if (!is.null(rownames.text.size) && show.rownames == TRUE) hplot <- hplot + theme(axis.text.y = element_text(size = rownames.text.size))
  if (show.rownames == FALSE) hplot <- hplot + theme(axis.text.y = element_blank())
  if (show.colnames == FALSE) hplot <- hplot + theme(axis.text.x = element_blank()) else hplot <- hplot + theme(axis.text.x=element_text(angle = 45, hjust = 0))
  return(hplot)
}

#' Plot the density of maximum sample weights in a model
#' 
#' Useful for determining how well samples map to a feature model in hard clusterings
#' 
#' @param h model
#' @returns ggplot2 object
#' @export
#' 
mdensity <- function(h) {
  df <- data.frame("max" = apply(h, 2, max))
  p <- ggplot(df, aes(x = max)) +
    geom_density() +
    theme_classic() +
    theme(aspect.ratio = 1) +
    xlab("max sample weight") +
    ylab("density") +
    geom_vline(aes(xintercept = mean(max)), color = "gray", linetype = "dashed", size = 1) +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0))
  return(p)
}



#' Plot model convergence statistics across iterations
#' 
#' Given a model generated with \code{full_path = TRUE}, visualize the decrease in \eqn{h}, \eqn{w} loss and compare against the loss of the model (if applicable).
#'
#' @param object valid \code{nmfmodel} object
#' @returns ggplot2 plot
#' @export
#' @import data.table
#' 
setGeneric("convergencePlot", function(object) standardGeneric("convergencePlot")) 

#' Plot model convergence statistics across iterations
#' 
#' Given a model generated with \code{full_path = TRUE}, visualize the decrease in \eqn{h}, \eqn{w} loss and compare against the loss of the model (if applicable).
#'
#' @param object valid \code{nmfmodel} object
#' @returns ggplot2 plot
#' @export
#' @import data.table
#' 
setMethod("convergencePlot", signature("nmfmodel"), function(object) {
  if(length(object@path) == 0) stop("this nmf model was not generated with full_path = TRUE")
  tol_loss <- sapply(object@path, function(x) x@tol_loss)
  tol_wh <- sapply(object@path, function(x) x@tol_wh)
  it <- sapply(object@path, function(x) x@it)
  it <- data.frame(it)
  colnames(it) <- c("iter")
  it["rel change in wh"] <- tol_wh
  if(!any(is.na(tol_loss))) it["rel. change in loss"] <- tol_loss
  it <- data.table(it)
  it <- melt(it, id.vars = c("iter"))
  p1 <- ggplot(it, aes(x = iter, y = value, color = variable)) + 
    geom_point() + 
    geom_line() + 
    theme_classic() + 
    labs(x = "Iteration", y = "Relative change\nacross consecutive iterations", color = "indicator of\nconvergence") + 
    scale_x_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1))))) + 
    theme(aspect.ratio = 1) + scale_y_continuous(trans = "log10")   
  return(p1);
})

# submit a model or a named list of models. Plot loss across iterations.
plot_loss <- function(models){
  if(!is.list(models)) models <- list(models)
  if(is.null(names(models))) names(models) <- paste0("model", 1:length(models))
  plotdt <- list()
  for(i in 1:length(models)){
    plotdt[[i]] <- data.table("iter" = sapply(models[[i]]@path, function(x) x@it),
                     "loss" = sapply(models[[i]]@path, function(x) x@loss),
                     "model" = names(models)[i])
  }
  plotdt <- do.call(rbind, plotdt)
  p1 <- ggplot(plotdt, aes(x = iter, y = loss, color = model)) + 
    geom_point() + 
    geom_line() + 
    theme_classic() + 
    labs(x = "Iteration", y = "Loss", color = "Model") + 
    scale_x_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1))))) + 
    theme(aspect.ratio = 1) 
  return(p1);
}

# submit a model or a named list of models. Plot loss tolerance across iterations.
plot_loss_tol <- function(models){
  if(!is.list(models)) models <- list(models)
  if(is.null(names(models))) names(models) <- paste0("model", 1:length(models))
  plotdt <- list()
  for(i in 1:length(models)){
    plotdt[[i]] <- data.table("iter" = sapply(models[[i]]@path, function(x) x@it),
                              "loss_tol" = sapply(models[[i]]@path, function(x) x@tol_loss),
                              "model" = names(models)[i])
  }
  plotdt <- do.call(rbind, plotdt)
  p1 <- ggplot(plotdt, aes(x = iter, y = loss_tol, color = model)) + 
    geom_point() + 
    geom_line() + 
    theme_classic() + 
    labs(x = "Iteration", y = "rel. change in loss\nbetween consecutive iterations", color = "Model") + 
    scale_x_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1))))) + 
    theme(aspect.ratio = 1) + scale_y_continuous(trans = "log10")
  return(p1);
}

# submit a model or a named list of models. Plot change in wh 
plot_wh_tol <- function(models){
  if(!is.list(models)) models <- list(models)
  if(is.null(names(models))) names(models) <- paste0("model", 1:length(models))
  plotdt <- list()
  for(i in 1:length(models)){
    plotdt[[i]] <- data.table("iter" = sapply(models[[i]]@path, function(x) x@it),
                              "wh_tol" = sapply(models[[i]]@path, function(x) x@tol_wh),
                              "model" = names(models)[i])
  }
  plotdt <- do.call(rbind, plotdt)
  p1 <- ggplot(plotdt, aes(x = iter, y = wh_tol, color = model)) + 
    geom_point() + 
    geom_line() + 
    theme_classic() + 
    labs(x = "Iteration", y = "rel. change in \"w\" * rel. change in \"h\"\nacross consecutive iterations", color = "Model") + 
    scale_x_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1))))) + 
    theme(aspect.ratio = 1) + scale_y_continuous(trans = "log10")
  return(p1);
}